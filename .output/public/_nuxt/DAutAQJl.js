import{g as d,A as N,B as P,C as j,D as l,E as x,G as S,i as v,H as L,z as _,I as O,P as c,J as y,K as w,L as A,S as T,k as h,M as R,N as B,O as E,Q as C}from"./DkB6kJVT.js";const g=B,H=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,s){return()=>y(l[e.name],e.layoutProps,s.slots)}}),M={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},W=d({name:"NuxtLayout",inheritAttrs:!1,props:M,setup(e,s){const t=N(),u=v(c),o=!u||u===P()?L():u,a=_(()=>{let n=h(e.name)??o?.meta.layout??g(o?.path).appLayout??"default";return n&&!(n in l)&&e.fallback&&(n=h(e.fallback)),n}),i=O();s.expose({layoutRef:i});const r=t.deferHydration();if(t.isHydrating){const n=t.hooks.hookOnce("app:error",r);j().beforeEach(n)}let p;return()=>{const n=a.value&&a.value in l,f=o?.meta.layoutTransition??x,k=p;return p=a.value,S(n&&f,{default:()=>y(T,{suspensible:!0,onResolve:()=>{A(r)}},{default:()=>y(I,{layoutProps:w(s.attrs,o.meta.layoutProps??{},{ref:i}),key:a.value||void 0,name:a.value,shouldProvide:!e.name,isRenderingNewLayout:m=>m!==k&&m===a.value,hasTransition:!!f},s.slots)})}).default()}}}),I=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(e,s){const t=e.name;e.shouldProvide&&R(E,{isCurrent:o=>t===!1||t===(o.meta.layout??g(o.path).appLayout??"default")});const u=v(c);if(u&&u===P()){const o=L(),a={};for(const i in o){const r=i;Object.defineProperty(a,r,{enumerable:!0,get:()=>e.isRenderingNewLayout(e.name)?o[r]:u[r]})}R(c,C(a))}return()=>!t||typeof t=="string"&&!(t in l)?s.slots.default?.():y(H,{key:t,layoutProps:e.layoutProps,name:t},s.slots)}});export{W as _};
